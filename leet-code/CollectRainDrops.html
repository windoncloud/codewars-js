<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p> collect rain drops [0,1,0,2,1,0,1,3,2,1,2,1]</p>
<img src="./img/rainwatertrap.png" alt="">
<div id="result"></div>
<script>
    let target = [0,1,0,2,1,0,1,3,2,1,2,1]
    /**
     * dynamic programming 动态规划
     */
    // 思路，从左至右，从右至左分别依次扫描，记录当前柱子的最高处。
    // 累加左右扫描高度的高度差减去当前数组的高度值
    // 时间复杂度 O(n) 空间复杂度 O(n)
    var trap1 = function (height) {
        let ans = 0
        let len = height.length
        if (len < 3) return 0
        let left_max_arr = []
        let right_max_arr = []
        left_max_arr[0] = height[0]
        right_max_arr[len-1] = height[len-1]
        for (let i = 1; i < len; i++) {
            left_max_arr[i] = Math.max(left_max_arr[i-1], height[i])
        }
        for (let i = len - 2; i >=0; i--) {
            right_max_arr[i] = Math.max(right_max_arr[i+1], height[i])
        }
        for (let i = 0; i < len; i++) {
            ans += Math.min(left_max_arr[i], right_max_arr[i]) - height[i]
        }
        return ans
    }
    let result1 = trap1(target)
    console.log('result1', result1)
    /**
     * 栈的应用
     */
    // 当前条形块小于或等于栈顶的条形块，我们就将条形快的索引引入栈，意思是
    // 当前的条形块被栈中的前一个条形块界定，如果我们发现一个条形块长于栈顶，
    // 我们可以确定栈顶的条形块被当前条形块和栈前的一个条形块界定，因此我们
    // 可以弹出栈顶元素并且累加答案到 ans
    var trap2 = function (height) {
        let ans = 0, current = 0
        let st = []
        while (current < height.length) {
            while (st.length !== 0 && height[current] > height[st[0]]) {
                let top = st[0]
                st.pop()
                if (st.length === 0) {
                    break
                }
                let distance = current - st[0] - 1
                let bounded_height = Math.min(height[current], height[st[0]]) - height[top]
                ans += distance * bounded_height
            }
            st.push(current++)
        }
        return ans
    }
    // 结果不对，待完善
    let result2 = trap2(target)
    console.log('result2', result2)
    /**
     * @param {number[]} height
     * @return {number}
     */
    var trap = function (height) {
        let left = 0, right = height.length - 1
        let count = 0
        let leftMax = 0, rightMax = 0
        const _debugArr = []
        const _debugCount = []
        while (left <= right) {
            leftMax = Math.max(leftMax, height[left])
            rightMax = Math.max(rightMax, height[right])
            if (leftMax < rightMax) {
                count += leftMax - height[left]
                left++
            } else {
                count += rightMax - height[right]
                right--
            }
            _debugArr.push([left, right])
            _debugCount.push(count)
        }
        console.log('_height-len', height.length)
        console.log('_debugArr', _debugArr)
        console.log('_debugCount', _debugCount)
        return count
    };
    let result = trap(target)
    console.log('result', result)
    document.getElementById('result').innerHTML = 'The result is ' + result

    // https://leetcode-cn.com/problems/trapping-rain-water/solution/
    // https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/
</script>
</body>
</html>
